\chapter{Related Work}\label{chap:relatedwork}

\todo{remove deepTools entirely}

\todo{Add Glossary?}

\todo{use more formal language}

\todo{write poolmanagers for printing}


Since the main work is the implementation in Rust as well as the testing of an
integrating in Python, related work includes the original implementation in
Python as well as the recent implementation of the KR-algorithm in C++.
We will take a look at how they have been implemented, advantages and
disadvantages.

 The description of the implemented algorithm can be found in \secref{sec:ICE}.


\section{Python implementation}\label{sec:python}

\todo{remove deeptools, written python because HiCExplorer, not deepTools}

\todo{hard to make things actually wrong, fast to implement}

\todo{python having a global interpreter lock for its multiprocessing module, needing to copy the RAM, sometimes numpy is using parallelization, dependent on version}

The original implementation was written in Python, since the
deepTools-framework is mainly written in Python. This implementation is using
common python dependencies extensively, including the Compressed Sparse Row
Matrix (CSR Matrix) implementation from \verb|scipy| (more information can be found
here\footnote{\url{https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html},
accessed 2019-06-26}), as well as the scientific number manipulation library
\verb|numpy|\footnote{\url{https://www.numpy.org/}, accessed 2019-06-26}.

The implementation itself is considerably short, the file having only 86 Lines,
including imports and frequent comments. The advantage of using Python here is
showing, as most imports are not for functionality, but rather for timing and
logging. With the iteration itself starting no earlier than Line 40, most
are High-Level \verb|numpy| / \verb|scipy| commands, some being themselves
implemented in C/C++ to be sufficiently fast.

The downsides of this implementation being that datastructures in Python are
extensively objectified, meaning they require more working memory, and that
even though Python has existing parallelism, a global interpreter lock (python
is only interpreted usually, but this still holds for compiling with cpython)
prevents multiple threads to use the same parts of memory without duplication.
Since Python already has comparatively high memory requirements \draft{link
high memory needs}, it is not practicable to add the same amount for every
further core.

For reference, the Python-implementation can be found
here\footnote{\url{https://github.com/deeptools/HiCExplorer/blob/master/hicexplorer/iterativeCorrection.py},
accessed 2019-06-26}.




\section{KR-algorithm}\label{sec:KR}

\draft{describe C++ implementation (the algorithm only superficially), advantages, disadvantages, specific implementation details (C-API, calls from Python to C++, ...)}

What follows is a short description to the Algorithm known as Knight-Ruiz from
\cite{knight2013fast}, as this algorithm is inherently different from ICE being
described later and implemented in both other implementations
(the ICE algorithm is described in \secref{sec:ICE}).

\todo{add negatives of using C++}

\extend{total support: at least one nonzero diagonal}

\draft{compare implementations: libraries: eigen + openMP}


\todo{read paper / algorithm + introduce here}

For reference, the implementation of the KR algorithm can be found here\footnote{\url{https://github.com/deeptools/Knight-Ruiz-Matrix-balancing-algorithm}, accessed 2019-06-26}.











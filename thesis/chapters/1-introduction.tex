\chapter{Introduction}\label{chap:introduction}

% \todo{include feedback!}
% Feedback:
% Why do we care about the 3D structure -> about the structure, influencing
% enhancer-promoter interactions, existing in reality in 3D and we have barely
% information, we want to understand this
%
% gene regulation also happening in 3D, way bigger why we want this
%
% around 1.5 Pages here
%
% removing the Eigenvector part, only mention it at the analysis, or when
% introducing the algorithm
%
% also mention: we have that data -> why do we want to correct it to begin with
%
% 'storytelling' introduction:
% - first: HiC and why it is interesting
% - errors that can happen to the data
% - super small introduction to rust
% - problem introduction
%
% sequencing errors:
% - some reagions are more sensible for biotin labeling enrichments
% - PCR duplicates: regions have multiple reads
% - mapping: certain locations are unclear, could be mapped to several different ones
% - random interactions -> may be technical errors or correct
% - mapping: location wrong, highly repetitive regions
% - illumina: more likely to get certain mapping errors
% - mapping algorithm has bias itself
% - mismatches likelier for longer reads
% => Errors do exist, but do not really know which ones or how to filter them out

\draft{rewrite. Make more fluent for readers.}

\draft{remove ``stuff'' and (stuff)}

Enhancers are usually searched for within a distance of 1 Mb up or downstream
of promoters \cite{pennacchio2013enhancers}. Structures such as DNA loops (see
\figref{fig:HiCMatricesModels}) can bring together an enhancer with a promoter
that is far more distant than 1 Mb however \cite{pennacchio2013enhancers}. With
Hi-C interactions over the whole genome \cite{lieberman2009comprehensive}, and
even across genomes can be measured \cite{rao20143d}. For the further study of
enhancer-promoter interactions it is important to also include information
about long-range three dimensional genomic interactions.

In this work, data obtained from Hi-C (see \chapref{chap:experiments} for
details) will be used. Hi-C is a method for aquiring 3D-information of genomes.
This is done by strapping together parts of the genome that are close by,
cutting the genome apart with restriction enzymes, combining the ends of
strapped-together fragments and using high throughput methods for sequencing
them. This is explained in detail in \secref{sec:HiC}.


Such technologies tend to suffer from biological, e.g. different chromatin
states \cite{pmid19693276}, and technical factors, e.g. sequencing and mapping
\cite{pmid21646344}, making them inherently inaccurate. Biases are unavoidable,
in particular, as some regions are more sensible for biotin labeling
enrichments (See \secref{sec:pulldown} why this is relevant) they will be
measured more often when compared to others. PCR artifacts may be one of the
reasons \cite{wingett2015hicup}. Mapping locations may be unclear or not
unique, introducing even more sources for possible biases. Sequencing methods
have certain biases themselves. Some of the measured interactions are
questionable, it is unclear if these are actual, spatially close points, or if
it simply is a technical error or a randomly happened interaction.

However, a basic but strong assumption about the structure of the genome can be
made, which is that every location has the same amount of interactions (with
other locations) as every other location. The data does not show this due to
the several aforementioned inaccuracies. Algorithms such as ICE
\cite{imakaev2012iterative} (Iterative Correction and Eigenvector
decomposition, \secref{sec:ICE}) or KR \cite{knight2013fast} (Knight-Ruiz,
\secref{sec:KR}) can be applied to normalize the matrix nonetheless.



% \section{Motivation}\label{sec:motivation}
%
% \subsection{Motivation for Hi-C}
%
% \todo{include in storytelling}
%
% Within cells, the three-dimensional structure of chromatin can now be analyzed
% using techniques based on chromatin conformation capture (3C), including Hi-C.
% With Hi-C \draft{what is the long name?}, we can construct spatial proximity
% maps over the whole genome, giving us clues as to which regions are close to
% each other. With 3C it can be tested if two genomic locations are close to each
% other, but with Hi-C we get (biased but still) all spatial connections of the
% genome at once.
%
% \subsection{Motivation for Rust}
%
% There is several reasons for using Rust, including faster development than C++
% and better tooling, while still having the same if not slightly better
% performance. A massive advantage is the easiness of adding parallelism, and the
% modularity of Rust code. Libraries in Rust can easily be stacked, and the
% compiler will complain if the memory is not handled the way it should be (in
% C++ it is hard to correctly manage all memory, especially from libraries,
% easily resulting in segfaults and similar issues hard to debug). The benefits to
% using Rust instead of Python are only apparent if performance or safety (of
% execution, at runtime) is needed - which is the case here.
%
% \todo{explain this more: thread safety, modularity, stackability, hard to debug C++}



\section{Task Definition}\label{sec:task}

In the three-dimensional space of a cell the DNA forms a structure that is
scrambled all around the place. Obviously, there exist many points of contact
in the DNA, they even form noticable structures, such as DNA loops. Many
measured points of contact are random interactions or measurement errors that
need to be corrected. For this task, a Python implementation exists but is
limited for high resolution data due to high memory usage. This thesis aims to
reimplement a more resource efficient method in Rust.

The main goals include testing the integration between Rust, a systems
programming language recently gaining in popularity (more information in
\secref{sec:Rust}), and Python, how easy it is to let both of these languages
interact, and how it compares to the other two current implementations (ICE in
Python and KR in C++, more information can be found in \secref{sec:python} and
\secref{sec:KR} respectively). The overall goal is to try to implement a more
resource efficient version, able to make effective use of parallel computing.


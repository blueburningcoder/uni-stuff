\chapter{Introduction}\label{chap:introduction}

% \todo{include feedback!}
% Feedback:
% Why do we care about the 3D structure -> about the structure, influencing
% enhancer-promoter interactions, existing in reality in 3D and we have barely
% information, we want to understand this
%
% gene regulation also happening in 3D, way bigger why we want this
%
% around 1.5 Pages here
%
% removing the Eigenvector part, only mention it at the analysis, or when
% introducing the algorithm
%
% also mention: we have that data -> why do we want to correct it to begin with
%
% 'storytelling' introduction:
% - first: HiC and why it is interesting
% - errors that can happen to the data
% - super small introduction to rust
% - problem introduction
%
% sequencing errors:
% - some reagions are more sensible for biotin labeling enrichments
% - PCR duplicates: regions have multiple reads
% - mapping: certain locations are unclear, could be mapped to several different ones
% - random interactions -> may be technical errors or correct
% - mapping: location wrong, highly repetitive regions
% - illumina: more likely to get certain mapping errors
% - mapping algorithm has bias itself
% - mismatches likelier for longer reads
% => Errors do exist, but do not really know which ones or how to filter them out

\draft{rewrite. Make more fluent for readers.}

Enhancers are
small protein-binding regions of DNA,
usually searched for within a distance of 1 Mbp up or downstream
of promoters \cite{pennacchio2013enhancers},
which initiate the process of transcription.
Structures such as DNA loops (see
\figref{fig:HiCMatricesModels}), however, can bring together an enhancer with a promoter
over distances far greater than 1 Mbp\cite{pennacchio2013enhancers}
due to the complex three-dimensional structure of the chromosome.
Using Hi-C technology, interactions over the whole genome \cite{lieberman2009comprehensive} and
even across different genomes can be measured \cite{rao20143d}.
Topologically-associating domains (TADs) describe regions which preferentially
interact with one another over others. Computational methods
using Hi-C data can identify hundreds of thousands of putative enhancers and their target genes by
searching for these TADs\cite{ron2017promoter}.

In this work, data obtained from Hi-C will be used (see \chapref{chap:results} for
details). Hi-C is a method for acquiring the 3D information of genomes.
This is done by strapping together parts of the genome that are close by,
and cutting the genome apart with restriction enzymes, combining the ends of
strapped-together fragments, and using high throughput methods to sequence
them. This is explained in detail in \secref{sec:HiC}.


Such technologies tend to suffer from unwanted biological and technical factors, such as different chromatin
states \cite{pmid19693276} and sequencing/mapping errors \cite{pmid21646344} respectively,
making them inherently inaccurate. Biases are unavoidable, and
some regions are more sensitive to biotin labelling
enrichment where they will be
measured more often when compared to others (See \secref{sec:pulldown} for relevant use-cases).
PCR artifacts may be one of the
reasons \cite{wingett2015hicup}, but multiply mapped loci also contribute to the ambiguity of the data,
introducing even more potential causes for bias. Specific sequencing methods also
have certain inherent biases \cite{aird2011analyzing}. The measured Hi-C interactions are
often questionable, since it is unclear if some of these interaction are spatially close points, or if
they are artefacts of technical errors, or even just randomly-occurring interactions.

However, a basic but strong assumption about the structure of the genome can be
made, which is that every location has the same amount of interactions with
other locations, as every other location. The data does not always show this due to
the several aforementioned unwanted biological and technical factors.

Corrective algorithms such as ICE \cite{imakaev2012iterative} (Iterative Correction and Eigenvector
decomposition, \secref{sec:ICE}) or KR \cite{knight2013fast} (Knight-Ruiz,
\secref{sec:KR}) can however still be applied to correct the matrix.



% \section{Motivation}\label{sec:motivation}
%
% \subsection{Motivation for Hi-C}
%
% \todo{include in storytelling}
%
% Within cells, the three-dimensional structure of chromatin can now be analyzed
% using techniques based on chromatin conformation capture (3C), including Hi-C.
% With Hi-C \draft{what is the long name?}, we can construct spatial proximity
% maps over the whole genome, giving us clues as to which regions are close to
% each other. With 3C it can be tested if two genomic locations are close to each
% other, but with Hi-C we get (biased but still) all spatial connections of the
% genome at once.
%
% \subsection{Motivation for Rust}
%
% There is several reasons for using Rust, including faster development than C++
% and better tooling, while still having the same if not slightly better
% performance. A massive advantage is the easiness of adding parallelism, and the
% modularity of Rust code. Libraries in Rust can easily be stacked, and the
% compiler will complain if the memory is not handled the way it should be (in
% C++ it is hard to correctly manage all memory, especially from libraries,
% easily resulting in segfaults and similar issues hard to debug). The benefits to
% using Rust instead of Python are only apparent if performance or safety (of
% execution, at runtime) is needed - which is the case here.
%
% \todo{explain this more: thread safety, modularity, stackability, hard to debug C++}



\section{Task Definition}\label{sec:task}

In the three-dimensional space of a cell the DNA forms a complex structure that is
distributed all over the place. Due to this structure, there exist many points of contact
in the DNA which form noticeable sub-structures, such as DNA loops. Many
of these measured points of contact are random interactions, or measurement errors that
need to be corrected. For this task, a Python implementation exists but it is
limited for high resolution data due to high memory usage. This thesis aims to
re-implement a more resource efficient method in Rust.

The main goals include: testing the integration between Rust, a systems
programming language recently gaining in popularity (details in
\secref{sec:Rust}), and Python; testing the inter-process communication between these two languages;
and comparing the two current matrix correction implementations, ICE in
Python and KR in C++. More information about these can be found in
\secref{sec:python} and \secref{sec:KR}, respectively. The overall goal is to
try to implement a more resource efficient version, able to make effective use
of parallel computing.


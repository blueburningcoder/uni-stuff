\chapter{Introduction}\label{chap:introduction}

\draft{Okay like this?}

Hi-C is a method commonly used for getting 3D-information of genomes. Such
technologies tend to suffer from technical (e.g. sequencing, mapping)
\cite{pmid21646344} and biological factors (e.g. distinct chromatin states)
\cite{pmid19693276}, making them inherently inaccurate.

However, a basic assumption about the structure of the genome can be made,
which is that every location has the same amount of interactions (with other
locations) as every other location. The data does not show this however, which
is probably due to PCR artifacts \cite{wingett2015hicup}.

Now our approach is to just take this assumption, and ``normalize'' the data we
have iteratively. Eigenvector decomposition of the normalized data can then
give us new insights on local chromatin states or global patterns of
chromosomal interaction \cite{imakaev2012iterative}.

We will not do the Eigenvector decomposition, but the iterative correction (``normalization'') before that.


\section{Core setup}\label{sec:setup}

\draft{Okay like this?}

This work is part of the HiCExplorer (\secref{sec:hicexplorer}) tool from the
Deeptools (\secref{sec:deeptools}) framework. HiCExplorer is mainly written in
Python, with this implementation needing too much working memory (RAM) for the
iterative correction. For some time, the goal was to reduce memory usage by not
copying a huge matrix a couple of times. From the Rust side, it would have been
possible to read and write to the matrix in-memory, but we decided against
doing so due to concerns regarding correctness. Still, the focus is to
investigate which version requires less resources (CPU Time/RAM/...).

This is going to be an interesting comparison, since, the (before) default
Python-implementation was only using one core. Rust code written for
single-core applications can easily be turned to multicore code. During the
work of this project, an implementation of a different algorithm
(\secref{sec:KR}) written in C++ got added, so We'll compare with this one now
as well.

\extend{maybe add more details}


\section{Algorithm}\label{sec:algorithm}
\todo{describe the algorithm}

\todo{Reference description from additional notes from the 2012-paper and} \extend{the description of the algorithm to be easily undarstandable, include code (probably pseudocode, not python or rust)}
Our fundamental assumption is that every location in our Matrix has in total as
many interactions (with other locations) as every other location.
Taking this in mind, the algorithm itself is pretty straightforward.


\section{Operation}\label{sec:operation}

\draft{Okay like this?}

\draft{Change Name!}
smb can be run on any Unix-based operating system (tested using ubuntu-18.04)
with Python, Rust and common development packages installed (e.g.
libopenssl-dev, python3-dev, build-essential, ...). For best performance, the
size of the matrix should correlate with the number of available cores and the
amount of available RAM \extend{Give rough factors!}.



\section{Motivation}\label{sec:motivation}

\draft{Okay like this?}

There is several reasons for using Rust, including faster development than C++
and better tooling, while still having the same if not better performance. A
killer feature here is the easiness of adding parallelism, and the modularity
of Rust code. Libraries in Rust do not do weird things, and the compiler will
complain if the memory is not handled the way it should be (in C++ it is common
practise to misunderstand which part should care about what memory, easily
resulting in Segfaults and other hard to debug issues). The benefits to using
Rust instead of Python are only apparent if Performance or Safety (of
execution, at runtime) is needed - which is the case here.

\todo{Add motivation for this whole Hi-C part}



